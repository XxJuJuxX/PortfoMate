export = ipfsClient;
/**
 * @param {import("./lib/core").ClientOptions} options
 */
declare function ipfsClient(options?: import("./lib/core").ClientOptions): {
    add: (input: import("ipfs-core-types/src/files").ToEntry, options?: (import("ipfs-core-types/src/root").AddAllOptions & HttpOptions) | undefined) => Promise<import("ipfs-core-types/src/files").UnixFSEntry>;
    addAll: (source: import("ipfs-core-types/src/files").ImportSource, options?: (import("ipfs-core-types/src/root").AddAllOptions & HttpOptions) | undefined) => AsyncIterable<import("ipfs-core-types/src/files").UnixFSEntry>;
    bitswap: {
        wantlist: (options?: (import("ipfs-core-types").AbortOptions & HttpOptions) | undefined) => Promise<CID[]>;
        wantlistForPeer: (peerId: string | CID | Uint8Array | import("peer-id"), options?: (import("ipfs-core-types").AbortOptions & HttpOptions) | undefined) => Promise<CID[]>;
        stat: (options?: (import("ipfs-core-types").AbortOptions & HttpOptions) | undefined) => Promise<import("ipfs-core/src/components/bitswap/stat").BitswapStats>;
        unwant: (cid: CID | CID[], options?: (import("ipfs-core-types").AbortOptions & HttpOptions) | undefined) => Promise<void>;
    };
    block: {
        get: (cid: string | CID | Uint8Array, options?: (import("ipfs-core/src/components/block/get").GetOptions & import("ipfs-core-types").AbortOptions & HttpOptions) | undefined) => Promise<import("ipfs-core-types/src/block-service").Block>;
        stat: (cid: CID, options?: (import("ipfs-core/src/components/block/stat").StatOptions & import("ipfs-core-types").AbortOptions & HttpOptions) | undefined) => Promise<import("ipfs-core/src/components/block/stat").Stat>;
        put: (data: Uint8Array | import("ipfs-core-types/src/block-service").Block, options?: (import("ipfs-core/src/components/block/put").PutOptions & import("ipfs-core-types").AbortOptions & HttpOptions) | undefined) => Promise<import("ipfs-core-types/src/block-service").Block>;
        rm: (cid: CID | CID[], options?: (import("ipfs-core/src/components/block/rm").RmOptions & import("ipfs-core-types").AbortOptions & HttpOptions) | undefined) => AsyncIterable<import("ipfs-core/src/components/block/rm").RmResult>;
    };
    bootstrap: {
        add: (addr: multiaddr, options?: (import("ipfs-core-types").AbortOptions & HttpOptions) | undefined) => Promise<import("ipfs-core/src/components/bootstrap/utils").Peers>;
        clear: (options?: (import("ipfs-core-types").AbortOptions & HttpOptions) | undefined) => Promise<import("ipfs-core/src/components/bootstrap/utils").Peers>;
        rm: (addr: multiaddr, options?: (import("ipfs-core-types").AbortOptions & HttpOptions) | undefined) => Promise<import("ipfs-core/src/components/bootstrap/utils").Peers>;
        reset: (options?: (import("ipfs-core-types").AbortOptions & HttpOptions) | undefined) => Promise<import("ipfs-core/src/components/bootstrap/utils").Peers>;
        list: (options?: (import("ipfs-core-types").AbortOptions & HttpOptions) | undefined) => Promise<import("ipfs-core/src/components/bootstrap/utils").Peers>;
    };
    cat: (path: import("ipfs-core-types/src/root").IPFSPath, options?: (import("ipfs-core-types/src/root").CatOptions & HttpOptions) | undefined) => AsyncIterable<Uint8Array>;
    commands: (options?: {}) => Promise<any>;
    config: {
        getAll: import("./interface").APIWithExtraOptions<(options?: import("ipfs-core-types").AbortOptions | undefined) => Promise<import("ipfs-core/src/components/config").IPFSConfig>, HttpOptions>;
        get: import("./interface").APIWithExtraOptions<(key: string, options?: import("ipfs-core-types").AbortOptions | undefined) => Promise<import("ipfs-core-types/src/basic").ToJSON>, HttpOptions>;
        set: import("./interface").APIWithExtraOptions<(key: string, value: import("ipfs-core-types/src/basic").ToJSON, options?: import("ipfs-core-types").AbortOptions | undefined) => Promise<void>, HttpOptions>;
        replace: import("./interface").APIWithExtraOptions<(value: import("ipfs-core/src/components/config").IPFSConfig, options?: import("ipfs-core-types").AbortOptions | undefined) => Promise<void>, HttpOptions>;
        profiles: {
            apply: (profile: any, options?: {}) => Promise<{
                original: any;
                updated: any;
            }>;
            list: (options?: {}) => Promise<any>;
        };
    };
    dag: {
        get: import("./interface").APIWithExtraOptions<(ipfsPath: import("ipfs-core-types/src/root").IPFSPath, options?: (import("ipfs-core/src/components/dag/get").GetOptions & import("ipfs-core-types").AbortOptions) | undefined) => Promise<import("ipfs-core/src/components/dag/get").DagEntry>, HttpOptions>;
        put: import("./interface").APIWithExtraOptions<(dagNode: any, options?: (import("ipfs-core/src/components/dag/put").WithCID & import("ipfs-core/src/components/dag/put").OtherPutOptions & import("ipfs-core-types").AbortOptions) | (import("ipfs-core/src/components/dag/put").WithCIDOptions & import("ipfs-core/src/components/dag/put").OtherPutOptions & import("ipfs-core-types").AbortOptions) | undefined) => Promise<CID>, HttpOptions>;
        resolve: import("./interface").APIWithExtraOptions<(ipfsPath: import("ipfs-core-types/src/root").IPFSPath, options?: (import("ipfs-core/src/components/dag/resolve").ResolveOptions & import("ipfs-core-types").AbortOptions) | undefined) => Promise<import("ipfs-core/src/components/dag/resolve").ResolveResult>, HttpOptions>;
    };
    dht: {
        get: (key: string | Uint8Array, options?: (import("ipfs-core-types").AbortOptions & HttpOptions) | undefined) => Promise<Uint8Array>;
        put: (key: Uint8Array, value: Uint8Array, options?: (import("ipfs-core-types").AbortOptions & HttpOptions) | undefined) => AsyncIterable<import("ipfs-core/src/components/dht").QueryEvent>;
        findProvs: (cid: CID, options?: (import("ipfs-core/src/components/dht").FindProvsOptions & import("ipfs-core-types").AbortOptions & HttpOptions) | undefined) => AsyncIterable<import("ipfs-core/src/components/dht").PeerInfo>;
        findPeer: (peerId: CID | import("peer-id"), options?: (import("ipfs-core-types").AbortOptions & HttpOptions) | undefined) => Promise<{
            id: string;
            addrs: multiaddr[];
        }>;
        provide: (cids: CID | CID[], options?: (import("ipfs-core/src/components/dht").ProvideOptions & import("ipfs-core-types").AbortOptions & HttpOptions) | undefined) => AsyncIterable<import("ipfs-core/src/components/dht").QueryEvent>;
        query: (peerId: string | import("peer-id"), options?: (import("ipfs-core-types").AbortOptions & HttpOptions) | undefined) => AsyncIterable<{
            id: CID;
            addrs: multiaddr[];
        }>;
    };
    diag: {
        net: (options?: {}) => Promise<any>;
        sys: (options?: {}) => Promise<any>;
        cmds: (options?: {}) => Promise<any>;
    };
    dns: import("./interface").APIWithExtraOptions<(domain: string, options?: import("ipfs-core/src/components/dns").DNSOptions | undefined) => Promise<string>, HttpOptions>;
    files: {
        chmod: (path: string, mode: string | number, options?: (import("ipfs-core/src/components/files/chmod").ChmodOptions & import("ipfs-core-types").AbortOptions & HttpOptions) | undefined) => Promise<void>;
        cp: (...args: [a1: import("ipfs-core-types/src/root").IPFSPath, options?: (import("ipfs-core/src/components/files/cp").CpOptions & HttpOptions) | undefined] | [a1: import("ipfs-core-types/src/root").IPFSPath, a2: import("ipfs-core-types/src/root").IPFSPath, options?: (import("ipfs-core/src/components/files/cp").CpOptions & HttpOptions) | undefined] | [a1: import("ipfs-core-types/src/root").IPFSPath, a2: import("ipfs-core-types/src/root").IPFSPath, a3: import("ipfs-core-types/src/root").IPFSPath, options?: (import("ipfs-core/src/components/files/cp").CpOptions & HttpOptions) | undefined]) => Promise<void>;
        flush: (path: string, options?: (import("ipfs-core-types").AbortOptions & HttpOptions) | undefined) => Promise<CID>;
        ls: (path: string, options?: (import("ipfs-core-types").AbortOptions & HttpOptions) | undefined) => AsyncIterable<import("ipfs-core/src/components/files/ls").UnixFSEntry>;
        mkdir: (path: string, options?: (import("ipfs-core/src/components/files/mkdir").MkdirOptions & import("ipfs-core-types").AbortOptions & HttpOptions) | undefined) => Promise<void>;
        mv: (...args: [a1: string, a2: string, options?: (import("ipfs-core/src/components/files/mv").MvOptions & HttpOptions) | undefined] | [a1: string, a2: string, a3: string, options?: (import("ipfs-core/src/components/files/mv").MvOptions & HttpOptions) | undefined]) => Promise<void>;
        read: (path: import("ipfs-core-types/src/root").IPFSPath, options?: (import("ipfs-core/src/components/files/read").ReadOptions & import("ipfs-core-types").AbortOptions & HttpOptions) | undefined) => AsyncIterable<Uint8Array>;
        rm: (...args: [a1: string, options?: (import("ipfs-core/src/components/files/rm").RmOptions & HttpOptions) | undefined] | [a1: string, a2: string, options?: (import("ipfs-core/src/components/files/rm").RmOptions & HttpOptions) | undefined] | [a1: string, a2: string, a3: string, options?: (import("ipfs-core/src/components/files/rm").RmOptions & HttpOptions) | undefined]) => Promise<void>;
        stat: (path: string, options?: (import("ipfs-core/src/components/files/stat").StatOptions & import("ipfs-core-types").AbortOptions & HttpOptions) | undefined) => Promise<import("ipfs-core/src/components/files/stat").Stat>;
        touch: (path: string, options?: (import("ipfs-core/src/components/files/touch").TouchOptions & import("ipfs-core-types").AbortOptions & HttpOptions) | undefined) => Promise<void>;
        write: (path: string, input: string | Uint8Array | AsyncIterable<Uint8Array> | Blob, options?: (import("ipfs-core/src/components/files/write").WriteOptions & import("ipfs-core-types").AbortOptions & HttpOptions) | undefined) => Promise<void>;
    };
    get: (path: import("ipfs-core-types/src/root").IPFSPath, options?: (import("ipfs-core-types/src/root").GetOptions & HttpOptions) | undefined) => AsyncIterable<import("ipfs-core-types/src/files").IPFSEntry>;
    getEndpointConfig: () => {
        host: string;
        port: string;
        protocol: string;
        pathname: string;
        'api-path': string;
    };
    id: (options?: (import("ipfs-core-types").AbortOptions & HttpOptions) | undefined) => Promise<import("ipfs-core/src/components/id").ID>;
    key: {
        gen: (name: any, options?: {}) => Promise<any>;
        list: (options?: {}) => Promise<any>;
        rename: (oldName: any, newName: any, options?: {}) => Promise<any>;
        rm: (name: any, options?: {}) => Promise<any>;
        import: (name: any, pem: any, password: any, options?: {}) => Promise<any>;
    };
    log: {
        tail: (options?: {}) => AsyncGenerator<any, void, undefined>;
        ls: (options?: {}) => Promise<any>;
        level: (subsystem: any, level: any, options?: {}) => Promise<any>;
    };
    ls: (path: any, options?: {}) => AsyncGenerator<{
        name: any;
        path: string;
        size: any;
        cid: CID;
        type: string;
        depth: any;
    }, void, undefined>;
    mount: (options?: {}) => Promise<any>;
    name: {
        publish: (path: any, options?: {}) => Promise<any>;
        resolve: (path: any, options?: {}) => AsyncGenerator<any, void, unknown>;
        pubsub: {
            cancel: (name: any, options?: {}) => Promise<any>;
            state: (options?: {}) => Promise<any>;
            subs: (options?: {}) => Promise<any>;
        };
    };
    object: {
        data: (cid: any, options?: {}) => Promise<Uint8Array>;
        get: (cid: any, options?: {}) => Promise<any>;
        links: (cid: any, options?: {}) => Promise<any>;
        new: (options?: {}) => Promise<CID>;
        patch: {
            addLink: (cid: any, dLink: any, options?: {}) => Promise<CID>;
            appendData: (cid: any, data: any, options?: {}) => Promise<CID>;
            rmLink: (cid: any, dLink: any, options?: {}) => Promise<CID>;
            setData: (cid: any, data: any, options?: {}) => Promise<CID>;
        };
        put: (obj: any, options?: {}) => Promise<CID>;
        stat: (cid: any, options?: {}) => Promise<any>;
    };
    pin: {
        add: (path: any, options?: {}) => Promise<CID | undefined>;
        addAll: (source: any, options?: {}) => AsyncGenerator<CID, void, unknown>;
        ls: (options?: {}) => AsyncGenerator<{
            type: any;
            cid: CID;
        }, void, unknown>;
        rm: (path: any, options?: {}) => Promise<any>;
        rmAll: (source: any, options?: {}) => AsyncGenerator<any, void, any>;
        remote: import("./pin/remote");
    };
    ping: (peerId: any, options?: {}) => AsyncGenerator<any, void, undefined>;
    pubsub: {
        ls: (options?: {}) => Promise<any>;
        peers: (topic: any, options?: {}) => Promise<any>;
        publish: (topic: any, data: any, options?: {}) => Promise<void>;
        subscribe: (topic: any, handler: any, options?: {}) => Promise<any>;
        unsubscribe: (topic: any, handler: any) => Promise<any>;
    };
    refs: {
        (args: any, options?: {}): AsyncGenerator<any, void, undefined>;
        local: (options?: {}) => AsyncGenerator<any, void, undefined>;
    };
    repo: {
        gc: (options?: {}) => AsyncGenerator<any, void, undefined>;
        stat: (options?: {}) => Promise<{
            numObjects: import("bignumber.js").default;
            repoSize: import("bignumber.js").default;
            repoPath: any;
            version: any;
            storageMax: import("bignumber.js").default;
        }>;
        version: (options?: {}) => Promise<any>;
    };
    resolve: (path: string, options?: (import("ipfs-core/src/components/resolve").ResolveSettings & import("ipfs-core-types").AbortOptions & HttpOptions) | undefined) => Promise<string>;
    stats: {
        bitswap: (options?: (import("ipfs-core-types").AbortOptions & HttpOptions) | undefined) => Promise<import("ipfs-core/src/components/bitswap/stat").BitswapStats>;
        bw: (options?: {}) => AsyncGenerator<any, void, undefined>;
        repo: (options?: {}) => Promise<{
            numObjects: import("bignumber.js").default;
            repoSize: import("bignumber.js").default;
            repoPath: any;
            version: any;
            storageMax: import("bignumber.js").default;
        }>;
    };
    stop: (options?: {}) => Promise<void>;
    shutdown: (options?: {}) => Promise<void>;
    swarm: {
        addrs: (options?: {}) => Promise<{
            id: string;
            addrs: any;
        }[]>;
        connect: (addrs: any, options?: {}) => Promise<any>;
        disconnect: (addrs: any, options?: {}) => Promise<any>;
        localAddrs: (options?: {}) => Promise<any>;
        peers: (options?: {}) => Promise<any>;
    };
    version: (options?: (import("ipfs-core-types").AbortOptions & HttpOptions) | undefined) => Promise<import("ipfs-core/src/components/version").Version>;
};
declare namespace ipfsClient {
    export { HttpOptions, AbortOptions, Implements, ImplementsMethod, APIWithExtraOptions };
}
type HttpOptions = {
    /**
     * - An object or [Headers](https://developer.mozilla.org/en-US/docs/Web/API/Headers) instance that can be used to set custom HTTP headers. Note that this option can also be [configured globally](#custom-headers) via the constructor options.
     */
    headers?: Headers | Record<string, string> | undefined;
    /**
     * - An object or [`URLSearchParams`](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams) instance that can be used to add additional query parameters to the query string sent with each request.
     */
    searchParams?: Record<string, string> | URLSearchParams | undefined;
};
import CID = require("cids");
import multiaddr = require("multiaddr");
/**
 * }
 */
type AbortOptions = import("ipfs-core-types").AbortOptions;
/**
 * This is an utility type that can be used to derive type of the HTTP Client
 * API from the Core API. It takes type of the API factory (from ipfs-core),
 * derives API from it's return type and extends it last `options` parameter
 * with `HttpOptions`.
 *
 * This can be used to avoid (re)typing API interface when implementing it in
 * http client e.g you can annotate `ipfs.addAll` implementation with
 *
 * `@type {Implements<typeof import('ipfs-core/src/components/add-all')>}`
 *
 * **Caution**: This supports APIs with up to four parameters and last optional
 * `options` parameter, anything else will result to `never` type.
 */
type Implements<APIFactory extends (config: any) => any> = import("./interface").APIWithExtraOptions<ReturnType<APIFactory>, HttpOptions>;
type ImplementsMethod<Key, APIFactory extends (config: any) => any> = ReturnType<APIFactory>[Key] extends (...args: any[]) => any ? import("./interface").APIWithExtraOptions<ReturnType<APIFactory>[Key], HttpOptions> : never;
type APIWithExtraOptions<API, Extra> = import("./interface").APIWithExtraOptions<API, Extra>;
//# sourceMappingURL=index.d.ts.map