/// <reference types="node" />
export = HTTP;
declare class HTTP {
    /**
     *
     * @param {HTTPOptions} options
     */
    constructor(options?: HTTPOptions);
    /** @type {HTTPOptions} */
    opts: HTTPOptions;
    /**
     * Fetch
     *
     * @param {string | Request} resource
     * @param {HTTPOptions} options
     * @returns {Promise<Response>}
     */
    fetch(resource: string | Request, options?: HTTPOptions): Promise<Response>;
    /**
     * @param {string | Request} resource
     * @param {HTTPOptions} options
     * @returns {Promise<Response>}
     */
    post(resource: string | Request, options?: HTTPOptions): Promise<Response>;
    /**
     * @param {string | Request} resource
     * @param {HTTPOptions} options
     * @returns {Promise<Response>}
     */
    get(resource: string | Request, options?: HTTPOptions): Promise<Response>;
    /**
     * @param {string | Request} resource
     * @param {HTTPOptions} options
     * @returns {Promise<Response>}
     */
    put(resource: string | Request, options?: HTTPOptions): Promise<Response>;
    /**
     * @param {string | Request} resource
     * @param {HTTPOptions} options
     * @returns {Promise<Response>}
     */
    delete(resource: string | Request, options?: HTTPOptions): Promise<Response>;
    /**
     * @param {string | Request} resource
     * @param {HTTPOptions} options
     * @returns {Promise<Response>}
     */
    options(resource: string | Request, options?: HTTPOptions): Promise<Response>;
}
declare namespace HTTP {
    export { HTTPError, TimeoutError, fromStream as streamToAsyncIterator, post, get, put, _delete as delete, options, Response, NodeReadableStream, NodeDuplexStream, HTTPOptions };
}
type HTTPOptions = import('./types').HTTPOptions;
import { Request } from "./http/fetch.node";
type Response = import('native-fetch').Response;
import { HTTPError } from "./http/error";
import { TimeoutError } from "./http/error";
/**
 * Stream to AsyncIterable
 *
 * @template TChunk
 * @param {ReadableStream<TChunk> | NodeReadableStream | null} source
 * @returns {AsyncIterable<TChunk>}
 */
declare function fromStream<TChunk>(source: import("stream").Readable | ReadableStream<TChunk> | null): AsyncIterable<TChunk>;
declare function post(resource: string | Request, options?: import("./types").HTTPOptions | undefined): Promise<Response>;
declare function get(resource: string | Request, options?: import("./types").HTTPOptions | undefined): Promise<Response>;
declare function put(resource: string | Request, options?: import("./types").HTTPOptions | undefined): Promise<Response>;
declare function options(resource: string | Request, options?: import("./types").HTTPOptions | undefined): Promise<Response>;
type NodeReadableStream = import('stream').Readable;
type NodeDuplexStream = import('stream').Duplex;
//# sourceMappingURL=http.d.ts.map